import { useState, useEffect, useCallback } from 'react';
import { recipes } from '../data/recipes';

const DAYS = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo'];
const MEAL_SLOTS = [
  { id: 'desayuno', label: 'Desayuno', types: ['Platillo Ligero'] },
  { id: 'comida', label: 'Comida', types: ['Platillo Principal'] },
  { id: 'cena', label: 'Cena', types: ['Platillo Ligero'] },
  { id: 'snack', label: 'Antojo', types: ['Antojo sin Culpa'] }
];

export function useSmartPlanner() {
  const [weekPlan, setWeekPlan] = useState({});
  const [version, setVersion] = useState(0);

  const getRecipesByType = (type) => recipes.filter(r => r.type === type);
  const getRandom = (arr) => arr.length > 0 ? arr[Math.floor(Math.random() * arr.length)] : null;

  // Generador que respeta huecos llenos o llena todo si está vacío
  const generateQuickMenu = useCallback((fillEmptyOnly = false) => {
    setWeekPlan(prevPlan => {
      const newPlan = fillEmptyOnly ? { ...prevPlan } : {};
      
      DAYS.forEach(day => {
        if (!newPlan[day]) newPlan[day] = {};
        
        MEAL_SLOTS.forEach(slot => {
          // Si solo llenamos vacíos y ya existe, saltar
          if (fillEmptyOnly && newPlan[day][slot.id]) return;

          // Lógica de selección
          const types = slot.types;
          const candidates = recipes.filter(r => types.includes(r.type));
          
          // 30% de probabilidad de no tener snack
          if (slot.id === 'snack' && Math.random() > 0.7) {
            newPlan[day][slot.id] = null;
          } else {
            newPlan[day][slot.id] = getRandom(candidates);
          }
        });
      });
      return newPlan;
    });
    setVersion(v => v + 1);
  }, []);

  useEffect(() => {
    const saved = localStorage.getItem('rm_smart_plan');
    if (saved && Object.keys(JSON.parse(saved)).length > 0) {
      setWeekPlan(JSON.parse(saved));
    } else {
      generateQuickMenu(false);
    }
  }, []);

  useEffect(() => {
    if (Object.keys(weekPlan).length > 0) {
      localStorage.setItem('rm_smart_plan', JSON.stringify(weekPlan));
    }
  }, [weekPlan]);

  const updateSlot = (day, slotId, recipe) => {
    setWeekPlan(prev => ({
      ...prev,
      [day]: { ...prev[day], [slotId]: recipe }
    }));
  };

  const shuffleSlot = (day, slotId) => {
    const slotConfig = MEAL_SLOTS.find(s => s.id === slotId);
    if (!slotConfig) return;
    const candidates = recipes.filter(r => slotConfig.types.includes(r.type));
    updateSlot(day, slotId, getRandom(candidates));
  };

  const calculateDailyStats = (day) => {
    const meals = weekPlan[day];
    if (!meals) return 0;
    let totalProtein = 0;
    MEAL_SLOTS.forEach(slot => {
      const recipe = meals[slot.id];
      if (recipe && recipe.proteina_aprox_g) {
        totalProtein += recipe.proteina_aprox_g;
      }
    });
    return Math.round(totalProtein);
  };

  return {
    weekPlan,
    generateQuickMenu,
    updateSlot,
    shuffleSlot,
    calculateDailyStats,
    days: DAYS,
    slots: MEAL_SLOTS,
    version
  };
}